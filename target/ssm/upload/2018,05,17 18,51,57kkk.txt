怎么样准确要继承 Thread 才可以实现多线程
 必须 重写public void run（） 方法。这是线程的执行体
  start 方法 是启动线程为准备就绪状态
Thread 类也继承 Runnable 接口。 Runnable 接口中只有一个run方法

Thread 不能直接用要继承以后才可以实现多线程，是因为run方法需要重写

Runnable 接口的方法多大于Thread 继承， 因为java 是单继承的，所以使用Runnable 比较好

Thread public void run 方法 源码 为 if（target != null）{target.run()} 其实就是调用传进去的 Runnable参数 的run 方法，用Runnable 实现多线程的操作为

 Thread st1 = new Thread（runnable）； 
 Thread st2 = new Thread（runnable）；

这个执行体都为 runnable ，所以他们的Run 方法执行都是相同区域， 所以当操作相同资源时候 使用 synchronized 

1）：适合多个相同的程序代码的线程去处理同一个资源

2）：可以避免java中的单继承的限制

3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立

线程和进程的区别是

程序是静态的（静态指令），进程是动态的，运行中的程序叫做进程。程序由一个或多个进程组成的，一个进程又包括多个线程，进程是资源分配的最小单位。线程是程序调度的基本单位，线程主要用于并发的实现。在一个进程中，这些线程能共享这个进程的系统资源。线程不具有系统资源，运行中不可少的资源一般存放在 寄存器中。同一个进程中，线程可以并发执行。线程可以创建或者销毁另一个进程

 线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序 健壮，但在进程切换时，耗费资源较大，效率要差一些。

1.Vector 的特点 2.拆箱装箱 3.Integer 和int 还有 Integer = new Integer（）。
自增容量。 capacity （） size（） 默认 的容量为 10  ，当实际容量大于初始化的容量。
如果没有设置 增量值，就是容量成倍数增长。

Class 类加载

实际上java中每个类都对应一个Class对象，当编写且编译一个新建类，就会产生一个Class对象。并且这个Class对象会被保存在相同名字的.class文件中。

当我们第一次new 这个类时候，或者给这个类静态变量赋值时候，JVM的子系统类加载器会根将对应的Class对象加载到JVM中，然后JVM根据类型信息来实例我们的类对象。JVM中每个类对应只有一个Class。

Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载


获取Class对象引用的方式3种，通过继承自Object类的getClass方法，Class类的静态方法forName以及字面常量的方式”.class”。

其中实例类的getClass方法和Class类的静态方法forName都将会触发类的初始化阶段，而字面常量获取Class对象的方式则不会触发初始化。

初始化是类加载的最后一个阶段，也就是说完成这个阶段后类也就加载到内存中(Class对象在加载阶段已被创建)，此时可以对类进行各种必要的操作了（如new对象，调用静态成员等），注意在这个阶段，才真正开始执行类中定义的Java程序代码或者字节码。


2）：可以避免java中的单继承的限制

3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立

线程和进程的区别是

程序是静态的（静态指令），进程是动态的，运行中的程序叫做进程。程序由一个或多个进程组成的，一个进程又包括多个线程，进程是资源分配的最小单位。线程是程序调度的基本单位，线程主要用于并发的实现。在一个进程中，这些线程能共享这个进程的系统资源。线程不具有系统资源，运行中不可少的资源一般存放在 寄存器中。同一个进程中，线程可以并发执行。线程可以创建或者销毁另一个进程

 线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序 健壮，但在进程切换时，耗费资源较大，效率要差一些。

1.Vector 的特点 2.拆箱装箱 3.Integer 和int 还有 Integer = new Integer（）。
自增容量。 capacity （） size（） 默认 的容量为 10  ，当实际容量大于初始化的容量。
如果没有设置 增量值，就是容量成倍数增长。
